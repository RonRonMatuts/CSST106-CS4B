# -*- coding: utf-8 -*-
"""4B-MatutoDelRio-Midterms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bbzq49dvAq_p724Lh002EI8Mwdx5Wuqc
"""

import cv2
from google.colab.patches import cv2_imshow

img = cv2.imread("/content/image/cat.jpg")

cv2_imshow(img)
cv2.waitKey(0)

classNames = []
classFile = "coco.names"
with open(classFile, "rt") as f:
  classNames = f.read().rstrip("\n").split("\n")

print(classNames)

configPath = "ssd_mobilenet_v3_large_coco_2020_01_14.pbtxt"
weightsPath = "frozen_inference_graph.pb"

net = cv2.dnn_DetectionModel(weightsPath, configPath)
net.setInputSize(320, 320)
net.setInputScale(1.0/127.5)
net.setInputMean((127.5, 127.5, 127.5))
net.setInputSwapRB(True)

classIds, confs, bbox = net.detect(img, confThreshold=0.7)

print(classIds, bbox)

for classId, confidence, box in zip(classIds.flatten(), confs.flatten(), bbox):
  x, y, w, h = box
  cv2.rectangle(img, (x, y), (x+w, y+h), color=(0, 255, 0), thickness=3)
  cv2.putText(img, classNames[classId-1].upper(), (x+10, y+30), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 255, 0), 2)

cv2_imshow(img)

"""**Full Code Script**"""

import cv2
import matplotlib.pyplot as plt
import pandas as pd
import os
import random
import time

# Set parameters
confidence_threshold = 0.7  # Confidence threshold for detection
min_box_area = 5000  # Minimum area of bounding box to be considered
image_folder = "/content/image"  # Folder containing input images
output_folder = "output_folder/"  # Folder to save output images

# Load class names
classNames = []
classFile = "coco.names"
with open(classFile, "rt") as f:
    classNames = f.read().rstrip("\n").split("\n")

# Create unique colors for each class
colors = {name: (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)) for name in classNames}

# Load the pre-trained model configuration and weights
configPath = "ssd_mobilenet_v3_large_coco_2020_01_14.pbtxt"
weightsPath = "frozen_inference_graph.pb"
net = cv2.dnn_DetectionModel(weightsPath, configPath)
net.setInputSize(320, 320)
net.setInputScale(1.0 / 127.5)
net.setInputMean((127.5, 127.5, 127.5))
net.setInputSwapRB(True)

# Create output directory if it doesn't exist
if not os.path.exists(output_folder):
    os.makedirs(output_folder)

# Metrics storage
process_times = []  # To store processing times per image

# Process each image in the folder
for filename in os.listdir(image_folder):
    img_path = os.path.join(image_folder, filename)
    img = cv2.imread(img_path)
    if img is None:
        continue  # Skip if the image could not be read

    start_time = time.time()  # Start timer

    # Keep copies for original and predicted images
    img_original = cv2.cvtColor(img.copy(), cv2.COLOR_BGR2RGB)  # Original for display (RGB)
    img_predicted = img.copy()  # For drawing predictions

    # Perform detection
    classIds, confs, bbox = net.detect(img_predicted, confThreshold=confidence_threshold)

    # Draw bounding boxes and labels on the predicted image
    for classId, confidence, box in zip(classIds.flatten(), confs.flatten(), bbox):
        x, y, w, h = box
        if w * h < min_box_area:
            continue  # Skip small boxes

        # Draw bounding box and label with color
        color = colors[classNames[classId - 1]]
        cv2.rectangle(img_predicted, (x, y), (x + w, y + h), color=color, thickness=3)
        label = f"{classNames[classId - 1].upper()} {confidence:.2f}"
        cv2.putText(img_predicted, label, (x + 10, y + 30), cv2.FONT_HERSHEY_COMPLEX, 1, color, 2)

    # Calculate processing time
    process_times.append(time.time() - start_time)

    # Convert img_predicted to RGB for matplotlib display
    img_predicted = cv2.cvtColor(img_predicted, cv2.COLOR_BGR2RGB)

    # Display original and predicted images side by side with titles
    plt.figure(figsize=(14, 7))
    plt.subplot(1, 2, 1)
    plt.imshow(img_original)
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(img_predicted)
    plt.title("Predicted Image")
    plt.axis("off")
    plt.show()

    # Save the predicted image to the output folder with .jpg extension
    output_path = os.path.join(output_folder, "predicted_" + os.path.splitext(filename)[0] + ".jpg")
    cv2.imwrite(output_path, cv2.cvtColor(img_predicted, cv2.COLOR_RGB2BGR))  # Convert back to BGR for saving
    print(f"Processed and saved: {output_path}")

# Function to calculate and display performance metrics
def calculate_performance_metrics(process_times):
    # Calculate average processing speed
    avg_speed = sum(process_times) / len(process_times) if process_times else 0
    print(f"\nPerformance Metrics:")
    print(f"Average Processing Time per Image: {avg_speed:.4f} seconds")
    print(f"Total Images Processed: {len(process_times)}")

# Call the function to calculate and display performance metrics
calculate_performance_metrics(process_times)

"""# **Evaluation**"""

# Add to the beginning of your code
import numpy as np

# Initialize lists to store confidence scores
confidence_scores = []

# Metrics storage
process_times = []  # To store processing times per image

# Process each image in the folder
for filename in os.listdir(image_folder):
    img_path = os.path.join(image_folder, filename)
    img = cv2.imread(img_path)
    if img is None:
        continue  # Skip if the image could not be read

    start_time = time.time()  # Start timer

    # Keep copies for original and predicted images
    img_original = cv2.cvtColor(img.copy(), cv2.COLOR_BGR2RGB)  # Original for display (RGB)
    img_predicted = img.copy()  # For drawing predictions

    # Perform detection
    classIds, confs, bbox = net.detect(img_predicted, confThreshold=confidence_threshold)

    # Draw bounding boxes and labels on the predicted image
    for classId, confidence, box in zip(classIds.flatten(), confs.flatten(), bbox):
        if w * h < min_box_area:
            continue  # Skip small boxes
        confidence_scores.append(confidence)  # Collect confidence scores

        # Draw bounding box and label with color
        color = colors[classNames[classId - 1]]
        cv2.rectangle(img_predicted, (x, y), (x + w, y + h), color=color, thickness=3)
        label = f"{classNames[classId - 1].upper()} {confidence:.2f}"
        cv2.putText(img_predicted, label, (x + 10, y + 30), cv2.FONT_HERSHEY_COMPLEX, 1, color, 2)

    # Calculate processing time
    process_times.append(time.time() - start_time)

    # Convert img_predicted to RGB for matplotlib display
    img_predicted = cv2.cvtColor(img_predicted, cv2.COLOR_BGR2RGB)

    # Display original and predicted images side by side with titles
    plt.figure(figsize=(14, 7))
    plt.subplot(1, 2, 1)
    plt.imshow(img_original)
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(img_predicted)
    plt.title("Predicted Image")
    plt.axis("off")
    plt.show()

    # Save the predicted image to the output folder with .jpg extension
    output_path = os.path.join(output_folder, "predicted_" + os.path.splitext(filename)[0] + ".jpg")
    cv2.imwrite(output_path, cv2.cvtColor(img_predicted, cv2.COLOR_RGB2BGR))  # Convert back to BGR for saving
    print(f"Processed and saved: {output_path}")

# Calculate and display performance metrics after processing all images
if confidence_scores:
    average_confidence = np.mean(confidence_scores)
    min_confidence = np.min(confidence_scores)
    max_confidence = np.max(confidence_scores)
    avg_processing_time = np.mean(process_times)
    total_processing_time = np.sum(process_times)

    print("\nPerformance Metrics:")
    print(f"Average Confidence Score: {average_confidence:.2f}")
    print(f"Min Confidence Score: {min_confidence:.2f}")
    print(f"Max Confidence Score: {max_confidence:.2f}")
    print(f"Average Processing Time per Image: {avg_processing_time:.2f} seconds")
    print(f"Total Processing Time: {total_processing_time:.2f} seconds")
else:
    print("\nNo detections were made.")